## 首先了解下概念：

synchronized的块内：

wait()：让进入临界区的当前线程挂起(即进入阻塞状态)，直到其它线程调用`锁对象`的notify(all)；
这时会让出锁的(让出监视器的所有权)，被notify(all)之后，需要重新竞争锁。

notify(all)()：通知其它等待该锁的线程，可以来竞争锁了。

## 为什么wait()和notify()属于Object类?

因为只有同步，线程持有的是`锁对象`，让线程等待或者通知线程必须对`锁对象`来操作，等待和唤醒必须是同一个锁。
所以，这个两个方法属于对象，而任何对象都有可作为`锁对象`，所以所有的对象都有这两个方法。

wait()和notify(all)必须在synchronized方法块中调用。否则直接调用的话，会抛异常，表明当前线程没有对应监视器(monitor)的所有权。



Lock.lock()和Lock.unlock()内：

await():

signal(all)():



## 顺带：

以下三个方法是线程的静态方法，不用在同步中执行。
yield:线程暂停，让出cpu资源，无法指定时间。
sleep:线程睡眠，暂停。
join:如果主线程是A，A中有一个子线程是B。用b.join()，那么这个方法执行
完毕后，主线程A才会继续执行下去。
